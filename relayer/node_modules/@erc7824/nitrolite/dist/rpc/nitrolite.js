"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NitroliteRPC = void 0;
const utils_1 = require("./utils");
class NitroliteRPC {
    static createRequest({ method, params = {}, requestId = (0, utils_1.generateRequestId)(), timestamp = (0, utils_1.getCurrentTimestamp)(), signatures = [], }) {
        const requestData = [requestId, method, params, timestamp];
        const message = { req: requestData, sig: signatures };
        return message;
    }
    static createAppRequest({ requestId = (0, utils_1.generateRequestId)(), method, params = {}, timestamp = (0, utils_1.getCurrentTimestamp)() }, sid) {
        const requestData = [requestId, method, params, timestamp];
        const message = { req: requestData, sid };
        return message;
    }
    static getMessagePayload(message) {
        if (message.req)
            return message.req;
        if (message.res)
            return message.res;
        throw new Error("Message must contain either 'req' or 'res' field");
    }
    static async signRequestMessage(message, signer) {
        if (!message.req) {
            throw new Error("signRequestMessage can only sign request messages containing 'req'.");
        }
        const payload = this.getMessagePayload(message);
        const signature = await signer(payload);
        message.sig = [signature];
        return message;
    }
    static async verifySingleSignature(message, expectedSigner, verifier) {
        if (!message.sig || !Array.isArray(message.sig) || message.sig.length === 0) {
            return false;
        }
        const signature = message.sig[0];
        if (message.sig.length > 1) {
            console.error('verifySingleSignature called on message with multiple signatures. Verifying only the first one.');
        }
        try {
            const payload = this.getMessagePayload(message);
            if (typeof signature !== 'string') {
                return false;
            }
            return await verifier(payload, signature, expectedSigner);
        }
        catch (error) {
            console.error('Error during single signature verification:', error);
            return false;
        }
    }
    static async verifyMultipleSignatures(message, expectedSigners, verifier) {
        if (!message.sig || !Array.isArray(message.sig)) {
            return false;
        }
        try {
            const payload = this.getMessagePayload(message);
            return await verifier(payload, message.sig, expectedSigners);
        }
        catch (error) {
            console.error('Error during multiple signature verification:', error);
            return false;
        }
    }
}
exports.NitroliteRPC = NitroliteRPC;
