"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.noop = exports.protocolVersionEnum = exports.statusEnum = exports.decimalSchema = exports.dateSchema = exports.bigIntSchema = exports.addressSchema = exports.hexSchema = exports.ParserParamsMissingError = void 0;
const zod_1 = require("zod");
const types_1 = require("../types");
class ParserParamsMissingError extends Error {
    constructor(method) {
        super(`Missing params for ${method} parser`);
        this.name = 'ParserParamsMissingError';
    }
}
exports.ParserParamsMissingError = ParserParamsMissingError;
exports.hexSchema = zod_1.z
    .string()
    .refine((val) => /^0x[0-9a-fA-F]*$/.test(val), {
    message: 'Must be a 0x-prefixed hex string',
})
    .transform((v) => v);
exports.addressSchema = zod_1.z
    .string()
    .refine((val) => /^0x[0-9a-fA-F]{40}$/.test(val), {
    message: 'Must be a 0x-prefixed hex string of 40 hex chars (EVM address)',
})
    .transform((v) => v);
exports.bigIntSchema = zod_1.z.string();
exports.dateSchema = zod_1.z.union([zod_1.z.string(), zod_1.z.date()]).transform((v) => new Date(v));
exports.decimalSchema = zod_1.z
    .union([zod_1.z.string(), zod_1.z.number()])
    .transform((v) => v.toString())
    .refine((val) => /^[+-]?((\d+(\.\d*)?)|(\.\d+))$/.test(val), {
    message: 'Must be a valid decimal string',
});
exports.statusEnum = zod_1.z.nativeEnum(types_1.RPCChannelStatus);
exports.protocolVersionEnum = zod_1.z.nativeEnum(types_1.RPCProtocolVersion);
const noop = (_) => {
    return {};
};
exports.noop = noop;
