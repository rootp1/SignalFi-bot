"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.channelParamsParsers = void 0;
const zod_1 = require("zod");
const types_1 = require("../types");
const common_1 = require("./common");
const RPCAllocationSchema = zod_1.z.object({
    destination: common_1.addressSchema,
    token: common_1.addressSchema,
    amount: common_1.bigIntSchema,
});
const ChannelOperationObject = zod_1.z.object({
    channel_id: common_1.hexSchema,
    state: zod_1.z.object({
        intent: zod_1.z.number(),
        version: zod_1.z.number(),
        state_data: common_1.hexSchema,
        allocations: zod_1.z.array(RPCAllocationSchema),
    }),
    server_signature: common_1.hexSchema,
});
const ChannelOperationObjectSchema = ChannelOperationObject.transform((raw) => ({
    channelId: raw.channel_id,
    state: {
        intent: raw.state.intent,
        version: raw.state.version,
        stateData: raw.state.state_data,
        allocations: raw.state.allocations.map((a) => ({
            destination: a.destination,
            token: a.token,
            amount: BigInt(a.amount),
        })),
    },
    serverSignature: raw.server_signature,
}));
const CreateChannelParamsSchema = zod_1.z
    .object({
    ...ChannelOperationObject.shape,
    channel: zod_1.z.object({
        participants: zod_1.z.array(common_1.addressSchema),
        adjudicator: common_1.addressSchema,
        challenge: zod_1.z.number(),
        nonce: zod_1.z.number(),
    }),
})
    .transform((raw) => ({
    ...ChannelOperationObjectSchema.parse(raw),
    channel: {
        participants: raw.channel.participants,
        adjudicator: raw.channel.adjudicator,
        challenge: raw.channel.challenge,
        nonce: raw.channel.nonce,
    },
}));
const ResizeChannelParamsSchema = ChannelOperationObjectSchema
    .transform((raw) => raw);
const CloseChannelParamsSchema = ChannelOperationObjectSchema
    .transform((raw) => raw);
const ChannelUpdateObject = zod_1.z.object({
    channel_id: common_1.hexSchema,
    participant: common_1.addressSchema,
    status: common_1.statusEnum,
    token: common_1.addressSchema,
    amount: common_1.bigIntSchema,
    chain_id: zod_1.z.number(),
    adjudicator: common_1.addressSchema,
    challenge: zod_1.z.number(),
    nonce: zod_1.z.number(),
    version: zod_1.z.number(),
    created_at: common_1.dateSchema,
    updated_at: common_1.dateSchema,
});
const ChannelUpdateObjectSchema = ChannelUpdateObject.transform((raw) => ({
    channelId: raw.channel_id,
    participant: raw.participant,
    status: raw.status,
    token: raw.token,
    amount: BigInt(raw.amount),
    chainId: raw.chain_id,
    adjudicator: raw.adjudicator,
    challenge: raw.challenge,
    nonce: raw.nonce,
    version: raw.version,
    createdAt: raw.created_at,
    updatedAt: raw.updated_at,
}));
const ChannelUpdateWithWalletObjectSchema = zod_1.z
    .object({
    ...ChannelUpdateObject.shape,
    wallet: common_1.addressSchema,
})
    .transform((raw) => ({
    ...ChannelUpdateObjectSchema.parse(raw),
    wallet: raw.wallet,
}));
const GetChannelsParamsSchema = zod_1.z
    .object({
    channels: zod_1.z.array(ChannelUpdateWithWalletObjectSchema),
})
    .transform((raw) => raw);
const ChannelUpdateParamsSchema = ChannelUpdateObjectSchema
    .transform((raw) => raw);
const ChannelsUpdateParamsSchema = zod_1.z
    .object({
    channels: zod_1.z.array(ChannelUpdateObjectSchema),
})
    .transform((raw) => raw);
exports.channelParamsParsers = {
    [types_1.RPCMethod.CreateChannel]: (params) => CreateChannelParamsSchema.parse(params),
    [types_1.RPCMethod.ResizeChannel]: (params) => ResizeChannelParamsSchema.parse(params),
    [types_1.RPCMethod.CloseChannel]: (params) => CloseChannelParamsSchema.parse(params),
    [types_1.RPCMethod.GetChannels]: (params) => GetChannelsParamsSchema.parse(params),
    [types_1.RPCMethod.ChannelUpdate]: (params) => ChannelUpdateParamsSchema.parse(params),
    [types_1.RPCMethod.ChannelsUpdate]: (params) => ChannelsUpdateParamsSchema.parse(params),
};
