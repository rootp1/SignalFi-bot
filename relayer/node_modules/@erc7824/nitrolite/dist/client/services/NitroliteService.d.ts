import { Account, Address, PublicClient, WalletClient, Hash } from 'viem';
import { ContractAddresses } from '../../abis';
import { Channel, ChannelData, ChannelId, Signature, State } from '../types';
type PreparedContractRequest = any;
export declare class NitroliteService {
    private readonly publicClient;
    private readonly walletClient?;
    private readonly account?;
    private readonly addresses;
    constructor(publicClient: PublicClient, addresses: ContractAddresses, walletClient?: WalletClient, account?: Account | Address);
    private ensureWalletClient;
    private ensureAccount;
    get custodyAddress(): Address;
    private convertChannelForABI;
    private convertStateForABI;
    private convertChannelFromContract;
    private convertStateFromContract;
    prepareDeposit(tokenAddress: Address, amount: bigint): Promise<PreparedContractRequest>;
    deposit(tokenAddress: Address, amount: bigint): Promise<Hash>;
    prepareCreateChannel(channel: Channel, initial: State): Promise<PreparedContractRequest>;
    createChannel(channel: Channel, initial: State): Promise<Hash>;
    prepareDepositAndCreateChannel(tokenAddress: Address, amount: bigint, channel: Channel, initial: State): Promise<PreparedContractRequest>;
    depositAndCreateChannel(tokenAddress: Address, amount: bigint, channel: Channel, initial: State): Promise<Hash>;
    prepareJoinChannel(channelId: ChannelId, index: bigint, sig: Signature): Promise<PreparedContractRequest>;
    joinChannel(channelId: ChannelId, index: bigint, sig: Signature): Promise<Hash>;
    prepareCheckpoint(channelId: ChannelId, candidate: State, proofs?: State[]): Promise<PreparedContractRequest>;
    checkpoint(channelId: ChannelId, candidate: State, proofs?: State[]): Promise<Hash>;
    prepareChallenge(channelId: ChannelId, candidate: State, proofs: State[] | undefined, challengerSig: Signature): Promise<PreparedContractRequest>;
    challenge(channelId: ChannelId, candidate: State, proofs: State[] | undefined, challengerSig: Signature): Promise<Hash>;
    prepareResize(channelId: ChannelId, candidate: State, proofs?: State[]): Promise<PreparedContractRequest>;
    resize(channelId: ChannelId, candidate: State, proofs?: State[]): Promise<Hash>;
    prepareClose(channelId: ChannelId, candidate: State, proofs?: State[]): Promise<PreparedContractRequest>;
    close(channelId: ChannelId, candidate: State, proofs?: State[]): Promise<Hash>;
    prepareWithdraw(tokenAddress: Address, amount: bigint): Promise<PreparedContractRequest>;
    withdraw(tokenAddress: Address, amount: bigint): Promise<Hash>;
    getOpenChannels(account: Address): Promise<ChannelId[]>;
    getOpenChannels(account: Address[]): Promise<ChannelId[][]>;
    getAccountBalance(user: Address, token: Address): Promise<bigint>;
    getAccountBalance(user: Address, token: Address[]): Promise<bigint[]>;
    getAccountBalance(user: Address[], token: Address): Promise<bigint[]>;
    getAccountBalance(user: Address[], token: Address[]): Promise<bigint[][]>;
    getChannelBalance(channelId: ChannelId, token: Address): Promise<bigint>;
    getChannelBalance(channelId: ChannelId, token: Address[]): Promise<bigint[]>;
    getChannelData(channelId: ChannelId): Promise<ChannelData>;
}
export {};
