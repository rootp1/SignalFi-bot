"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Erc20Service = void 0;
const token_1 = require("../../abis/token");
const errors_1 = require("../../errors");
const executeWriteContract = async (walletClient, request, account) => {
    return walletClient.writeContract({
        ...request,
        account,
    });
};
class Erc20Service {
    constructor(publicClient, walletClient, account) {
        if (!publicClient) {
            throw new errors_1.Errors.MissingParameterError('publicClient');
        }
        this.publicClient = publicClient;
        this.walletClient = walletClient;
        this.account = account || walletClient?.account;
    }
    ensureWalletClient() {
        if (!this.walletClient) {
            throw new errors_1.Errors.WalletClientRequiredError();
        }
        return this.walletClient;
    }
    ensureAccount() {
        if (!this.account) {
            throw new errors_1.Errors.AccountRequiredError();
        }
        return this.account;
    }
    async getTokenBalance(tokenAddress, account) {
        const functionName = 'balanceOf';
        try {
            const balance = await this.publicClient.readContract({
                address: tokenAddress,
                abi: token_1.Erc20Abi,
                functionName: functionName,
                args: [account],
            });
            return balance;
        }
        catch (error) {
            if (error instanceof errors_1.Errors.NitroliteError)
                throw error;
            throw new errors_1.Errors.ContractReadError(functionName, error, { tokenAddress, account });
        }
    }
    async getTokenAllowance(tokenAddress, owner, spender) {
        const functionName = 'allowance';
        try {
            const allowance = await this.publicClient.readContract({
                address: tokenAddress,
                abi: token_1.Erc20Abi,
                functionName: functionName,
                args: [owner, spender],
            });
            return allowance;
        }
        catch (error) {
            if (error instanceof errors_1.Errors.NitroliteError)
                throw error;
            throw new errors_1.Errors.ContractReadError(functionName, error, { tokenAddress, owner, spender });
        }
    }
    async prepareApprove(tokenAddress, spender, amount) {
        const account = this.ensureAccount();
        const operationName = 'prepareApprove';
        try {
            const { request } = await this.publicClient.simulateContract({
                address: tokenAddress,
                abi: token_1.Erc20Abi,
                functionName: 'approve',
                args: [spender, amount],
                account: account,
            });
            return request;
        }
        catch (error) {
            if (error instanceof errors_1.Errors.NitroliteError)
                throw error;
            throw new errors_1.Errors.ContractCallError(operationName, error, { tokenAddress, spender, amount });
        }
    }
    async approve(tokenAddress, spender, amount) {
        const walletClient = this.ensureWalletClient();
        const account = this.ensureAccount();
        const operationName = 'approve';
        try {
            const request = await this.prepareApprove(tokenAddress, spender, amount);
            return await executeWriteContract(walletClient, request, account);
        }
        catch (error) {
            if (error instanceof errors_1.Errors.NitroliteError)
                throw error;
            throw new errors_1.Errors.TransactionError(operationName, error, { tokenAddress, spender, amount });
        }
    }
}
exports.Erc20Service = Erc20Service;
