"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Errors = exports.ChannelNotFoundError = exports.StateNotFoundError = exports.InvalidStateTransitionError = exports.InsufficientAllowanceError = exports.InsufficientBalanceError = exports.TokenError = exports.TransactionError = exports.ContractCallError = exports.ContractReadError = exports.ContractNotFoundError = exports.AccountRequiredError = exports.WalletClientRequiredError = exports.NotParticipantError = exports.UnauthorizedError = exports.InvalidSignatureError = exports.MissingParameterError = exports.InvalidParameterError = exports.StateError = exports.ContractError = exports.AuthenticationError = exports.ValidationError = exports.NitroliteError = void 0;
class NitroliteError extends Error {
    constructor(message, code, statusCode, suggestion, details, cause) {
        super(message);
        this.name = this.constructor.name;
        this.code = code;
        this.statusCode = statusCode;
        this.suggestion = suggestion;
        this.details = details;
        this.cause = cause;
        Object.setPrototypeOf(this, new.target.prototype);
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            code: this.code,
            statusCode: this.statusCode,
            suggestion: this.suggestion,
            details: this.details,
            cause: this.cause
                ? { name: this.cause.name, message: this.cause.message, stack: this.cause.stack }
                : undefined,
        };
    }
    toString() {
        return `${this.name} [${this.code}]: ${this.message}`;
    }
}
exports.NitroliteError = NitroliteError;
class ValidationError extends NitroliteError {
    constructor(message, code = 'VALIDATION_ERROR', statusCode = 400, suggestion = 'Check input parameters', details, cause) {
        super(message, code, statusCode, suggestion, details, cause);
    }
}
exports.ValidationError = ValidationError;
class AuthenticationError extends NitroliteError {
    constructor(message, code = 'AUTHENTICATION_ERROR', statusCode = 401, suggestion = 'Check credentials, permissions, or signatures', details, cause) {
        super(message, code, statusCode, suggestion, details, cause);
    }
}
exports.AuthenticationError = AuthenticationError;
class ContractError extends NitroliteError {
    constructor(message, code = 'CONTRACT_ERROR', statusCode = 500, suggestion = 'Verify contract addresses, interactions, and network status', details, cause) {
        super(message, code, statusCode, suggestion, details, cause);
    }
}
exports.ContractError = ContractError;
class StateError extends NitroliteError {
    constructor(message, code = 'STATE_ERROR', statusCode = 400, suggestion = 'Check application state or channel status', details, cause) {
        super(message, code, statusCode, suggestion, details, cause);
    }
}
exports.StateError = StateError;
class InvalidParameterError extends ValidationError {
    constructor(message, details, cause) {
        super(message, 'INVALID_PARAMETER', 400, 'Check the parameter value against the expected type or format', details, cause);
    }
}
exports.InvalidParameterError = InvalidParameterError;
class MissingParameterError extends ValidationError {
    constructor(parameter, details, cause) {
        super(`Required parameter '${parameter}' is missing`, 'MISSING_PARAMETER', 400, `Provide the required '${parameter}' parameter`, details, cause);
    }
}
exports.MissingParameterError = MissingParameterError;
class InvalidSignatureError extends AuthenticationError {
    constructor(message = 'Invalid signature', details, cause) {
        super(message, 'INVALID_SIGNATURE', 401, 'Ensure the correct data was signed with the correct key', details, cause);
    }
}
exports.InvalidSignatureError = InvalidSignatureError;
class UnauthorizedError extends AuthenticationError {
    constructor(message = 'Unauthorized operation', details, cause) {
        super(message, 'UNAUTHORIZED', 403, 'You do not have permission to perform this operation', details, cause);
    }
}
exports.UnauthorizedError = UnauthorizedError;
class NotParticipantError extends UnauthorizedError {
    constructor(address, channelId, details, cause) {
        const addressStr = address ? ` ${address}` : '';
        const channelStr = channelId ? ` in channel ${channelId}` : '';
        const message = `Address${addressStr} is not a participant${channelStr}`;
        const combinedDetails = {
            ...details,
            address,
            channelId,
        };
        super(message, combinedDetails, cause);
        Object.defineProperty(this, 'code', { value: 'NOT_PARTICIPANT', writable: false });
        Object.defineProperty(this, 'suggestion', {
            value: 'Only channel participants can perform this operation',
            writable: false,
        });
    }
}
exports.NotParticipantError = NotParticipantError;
class WalletClientRequiredError extends AuthenticationError {
    constructor(details, cause) {
        super('WalletClient instance is required for this operation', 'WALLET_CLIENT_REQUIRED', 400, 'Provide a valid WalletClient instance during service initialization', details, cause);
    }
}
exports.WalletClientRequiredError = WalletClientRequiredError;
class AccountRequiredError extends AuthenticationError {
    constructor(details, cause) {
        super('Account is required for this operation', 'ACCOUNT_REQUIRED', 400, 'Ensure an account is associated with the WalletClient or provided explicitly', details, cause);
    }
}
exports.AccountRequiredError = AccountRequiredError;
class ContractNotFoundError extends ContractError {
    constructor(contractType = 'Contract', address, details, cause) {
        const addressStr = address ? ` at ${address}` : '';
        super(`${contractType}${addressStr} not found`, 'CONTRACT_NOT_FOUND', 404, `Verify the ${contractType.toLowerCase()} address in the configuration and ensure it's deployed on the correct network`, details, cause);
    }
}
exports.ContractNotFoundError = ContractNotFoundError;
class ContractReadError extends ContractError {
    constructor(functionName, cause, details) {
        super(`Failed to read from contract function '${functionName}'`, 'CONTRACT_READ_FAILED', 500, 'Check contract address, network connection, and function arguments', details, cause);
    }
}
exports.ContractReadError = ContractReadError;
class ContractCallError extends ContractError {
    constructor(functionName, cause, details) {
        super(`Contract call simulation failed for function '${functionName}'`, 'CONTRACT_CALL_FAILED', 400, 'Check contract call parameters, account balance/allowance, and contract state', details, cause);
    }
}
exports.ContractCallError = ContractCallError;
class TransactionError extends ContractError {
    constructor(operationName, cause, details) {
        super(`Transaction failed during operation '${operationName}'`, 'TRANSACTION_FAILED', 500, 'Verify transaction parameters, gas limits, nonce, and ensure sufficient funds/allowance. Check network status.', details, cause);
    }
}
exports.TransactionError = TransactionError;
class TokenError extends ContractError {
    constructor(message = 'Token operation failed', code = 'TOKEN_ERROR', statusCode = 400, suggestion = 'Check token address, balance, and allowance', details, cause) {
        super(message, code, statusCode, suggestion, details, cause);
    }
}
exports.TokenError = TokenError;
class InsufficientBalanceError extends TokenError {
    constructor(tokenAddress, required, actual, details, cause) {
        super('Insufficient token balance', 'INSUFFICIENT_BALANCE', 400, 'Ensure the account has enough tokens/ETH to complete this operation', {
            ...details,
            tokenAddress,
            required,
            actual,
        }, cause);
    }
}
exports.InsufficientBalanceError = InsufficientBalanceError;
class InsufficientAllowanceError extends TokenError {
    constructor(tokenAddress, spender, required, actual, details, cause) {
        super('Insufficient token allowance', 'INSUFFICIENT_ALLOWANCE', 400, 'Approve the spender for the required token amount before continuing', {
            ...details,
            tokenAddress,
            spender,
            required,
            actual,
        }, cause);
    }
}
exports.InsufficientAllowanceError = InsufficientAllowanceError;
class InvalidStateTransitionError extends StateError {
    constructor(message = 'Invalid state transition', details, cause) {
        super(message, 'INVALID_STATE_TRANSITION', 400, 'Ensure the state transition follows the application rules', details, cause);
    }
}
exports.InvalidStateTransitionError = InvalidStateTransitionError;
class StateNotFoundError extends StateError {
    constructor(entity = 'State', id, details, cause) {
        const idStr = id ? ` with ID ${id}` : '';
        super(`${entity}${idStr} not found`, 'STATE_NOT_FOUND', 404, `Verify that the ${entity.toLowerCase()} exists and is accessible`, details, cause);
    }
}
exports.StateNotFoundError = StateNotFoundError;
class ChannelNotFoundError extends StateNotFoundError {
    constructor(channelId, details, cause) {
        super('Channel', channelId, details, cause);
        Object.defineProperty(this, 'code', { value: 'CHANNEL_NOT_FOUND' });
        Object.defineProperty(this, 'suggestion', {
            value: 'Verify the channel ID and ensure the channel exists on-chain',
        });
    }
}
exports.ChannelNotFoundError = ChannelNotFoundError;
exports.Errors = {
    NitroliteError,
    ValidationError,
    AuthenticationError,
    ContractError,
    StateError,
    InvalidParameterError,
    MissingParameterError,
    InvalidSignatureError,
    UnauthorizedError,
    NotParticipantError,
    WalletClientRequiredError,
    AccountRequiredError,
    ContractNotFoundError,
    ContractReadError,
    ContractCallError,
    TransactionError,
    TokenError,
    InsufficientBalanceError,
    InsufficientAllowanceError,
    InvalidStateTransitionError,
    StateNotFoundError,
    ChannelNotFoundError,
};
exports.default = exports.Errors;
